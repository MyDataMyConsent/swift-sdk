//
// DataConsentRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Data consent request details. */
public struct DataConsentRequest: Codable, JSONEncodable, Hashable {

    /** Data consent request id. */
    public var id: UUID
    /** Data consent template id. */
    public var templateId: UUID?
    /** Data consent id. */
    public var consentId: UUID?
    /** Data consent title. */
    public var title: String
    /** Data consent description. */
    public var description: String
    /** Data consent purpose. */
    public var purpose: String?
    public var dataLife: Life?
    /** List of supported collectables. */
    public var collectables: [CollectibleTypes]
    public var receiver: ConsentRequestReceiver
    public var status: DataConsentStatus
    /** Request creation datetime in UTC timezone. */
    public var createdAtUtc: Date
    /** Request expiration datetime in UTC timezone. */
    public var expiresAtUtc: Date
    /** Request approval datetime in UTC timezone. */
    public var approvedAtUtc: Date?
    /** Data access expiration datetime in UTC timezone. */
    public var dataAccessExpiresAtUtc: Date?
    /** Request rejection datetime in UTC timezone. */
    public var rejectedAtUtc: Date?
    /** Request revocation datetime in UTC timezone. */
    public var revokedAtUtc: Date?

    public init(id: UUID, templateId: UUID? = nil, consentId: UUID? = nil, title: String, description: String, purpose: String? = nil, dataLife: Life? = nil, collectables: [CollectibleTypes], receiver: ConsentRequestReceiver, status: DataConsentStatus, createdAtUtc: Date, expiresAtUtc: Date, approvedAtUtc: Date? = nil, dataAccessExpiresAtUtc: Date? = nil, rejectedAtUtc: Date? = nil, revokedAtUtc: Date? = nil) {
        self.id = id
        self.templateId = templateId
        self.consentId = consentId
        self.title = title
        self.description = description
        self.purpose = purpose
        self.dataLife = dataLife
        self.collectables = collectables
        self.receiver = receiver
        self.status = status
        self.createdAtUtc = createdAtUtc
        self.expiresAtUtc = expiresAtUtc
        self.approvedAtUtc = approvedAtUtc
        self.dataAccessExpiresAtUtc = dataAccessExpiresAtUtc
        self.rejectedAtUtc = rejectedAtUtc
        self.revokedAtUtc = revokedAtUtc
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case templateId
        case consentId
        case title
        case description
        case purpose
        case dataLife
        case collectables
        case receiver
        case status
        case createdAtUtc
        case expiresAtUtc
        case approvedAtUtc
        case dataAccessExpiresAtUtc
        case rejectedAtUtc
        case revokedAtUtc
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encodeIfPresent(templateId, forKey: .templateId)
        try container.encodeIfPresent(consentId, forKey: .consentId)
        try container.encode(title, forKey: .title)
        try container.encode(description, forKey: .description)
        try container.encodeIfPresent(purpose, forKey: .purpose)
        try container.encodeIfPresent(dataLife, forKey: .dataLife)
        try container.encode(collectables, forKey: .collectables)
        try container.encode(receiver, forKey: .receiver)
        try container.encode(status, forKey: .status)
        try container.encode(createdAtUtc, forKey: .createdAtUtc)
        try container.encode(expiresAtUtc, forKey: .expiresAtUtc)
        try container.encodeIfPresent(approvedAtUtc, forKey: .approvedAtUtc)
        try container.encodeIfPresent(dataAccessExpiresAtUtc, forKey: .dataAccessExpiresAtUtc)
        try container.encodeIfPresent(rejectedAtUtc, forKey: .rejectedAtUtc)
        try container.encodeIfPresent(revokedAtUtc, forKey: .revokedAtUtc)
    }
}

