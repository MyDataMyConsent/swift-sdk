//
// UriDetails.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct UriDetails: Codable, JSONEncodable, Hashable {

    public var aadhaar: String
    public var uri: String
    public var docType: String
    public var docName: String
    public var docId: String
    public var issuedOn: String
    public var validFrom: String
    public var validTo: String?
    public var timestamp: String?
    public var action: String?

    public init(aadhaar: String, uri: String, docType: String, docName: String, docId: String, issuedOn: String, validFrom: String, validTo: String? = nil, timestamp: String? = nil, action: String? = nil) {
        self.aadhaar = aadhaar
        self.uri = uri
        self.docType = docType
        self.docName = docName
        self.docId = docId
        self.issuedOn = issuedOn
        self.validFrom = validFrom
        self.validTo = validTo
        self.timestamp = timestamp
        self.action = action
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case aadhaar
        case uri
        case docType
        case docName
        case docId
        case issuedOn
        case validFrom
        case validTo
        case timestamp
        case action
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(aadhaar, forKey: .aadhaar)
        try container.encode(uri, forKey: .uri)
        try container.encode(docType, forKey: .docType)
        try container.encode(docName, forKey: .docName)
        try container.encode(docId, forKey: .docId)
        try container.encode(issuedOn, forKey: .issuedOn)
        try container.encode(validFrom, forKey: .validFrom)
        try container.encodeIfPresent(validTo, forKey: .validTo)
        try container.encodeIfPresent(timestamp, forKey: .timestamp)
        try container.encodeIfPresent(action, forKey: .action)
    }
}

