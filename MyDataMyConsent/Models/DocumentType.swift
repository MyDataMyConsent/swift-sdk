//
// DocumentType.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** DocumentType : Issuable Document Type details. */
public struct DocumentType: Codable, JSONEncodable, Hashable {

    /** Document Type Identifier. */
    public var id: String
    public var categoryType: DocumentCategoryType
    public var subCategoryType: DocumentSubCategoryType
    /** Document Type Name. eg: Driving License. */
    public var name: String
    /** Document Type Unique Slug. eg: \\\"in.gov.gj.transport.dl\\\". */
    public var slug: String
    /** Document Type description. eg: Gujarat State Driving License. */
    public var description: String?
    /** Logo URL of document type. */
    public var logoUrl: String
    /** Document search repository service name. */
    public var searchServiceName: String?
    /** Document repository service name. */
    public var repositoryServiceName: String?
    public var supportedEntityType: SupportedEntityType
    /** Name of the document type creator. */
    public var addedBy: String
    /** Payable amount if document is chargeable. eg: 10.25. */
    public var payableAmount: Decimal
    /** Payable amount currency. eg: INR, USD etc.,. */
    public var payableAmountCurrency: String
    /** DateTime of approval in UTC timezone. */
    public var approvedAtUtc: Date?

    public init(id: String, categoryType: DocumentCategoryType, subCategoryType: DocumentSubCategoryType, name: String, slug: String, description: String? = nil, logoUrl: String, searchServiceName: String? = nil, repositoryServiceName: String? = nil, supportedEntityType: SupportedEntityType, addedBy: String, payableAmount: Decimal, payableAmountCurrency: String, approvedAtUtc: Date? = nil) {
        self.id = id
        self.categoryType = categoryType
        self.subCategoryType = subCategoryType
        self.name = name
        self.slug = slug
        self.description = description
        self.logoUrl = logoUrl
        self.searchServiceName = searchServiceName
        self.repositoryServiceName = repositoryServiceName
        self.supportedEntityType = supportedEntityType
        self.addedBy = addedBy
        self.payableAmount = payableAmount
        self.payableAmountCurrency = payableAmountCurrency
        self.approvedAtUtc = approvedAtUtc
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case categoryType
        case subCategoryType
        case name
        case slug
        case description
        case logoUrl
        case searchServiceName
        case repositoryServiceName
        case supportedEntityType
        case addedBy
        case payableAmount
        case payableAmountCurrency
        case approvedAtUtc
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(categoryType, forKey: .categoryType)
        try container.encode(subCategoryType, forKey: .subCategoryType)
        try container.encode(name, forKey: .name)
        try container.encode(slug, forKey: .slug)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encode(logoUrl, forKey: .logoUrl)
        try container.encodeIfPresent(searchServiceName, forKey: .searchServiceName)
        try container.encodeIfPresent(repositoryServiceName, forKey: .repositoryServiceName)
        try container.encode(supportedEntityType, forKey: .supportedEntityType)
        try container.encode(addedBy, forKey: .addedBy)
        try container.encode(payableAmount, forKey: .payableAmount)
        try container.encode(payableAmountCurrency, forKey: .payableAmountCurrency)
        try container.encodeIfPresent(approvedAtUtc, forKey: .approvedAtUtc)
    }
}

