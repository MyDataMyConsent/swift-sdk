//
// DocumentTypeDetailsDto.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct DocumentTypeDetailsDto: Codable, JSONEncodable, Hashable {

    public var id: UUID
    public var organizationId: UUID
    public var categoryType: DocumentCategoryType
    public var subCategoryType: DocumentSubCategoryType
    public var documentTypeCategoryId: UUID
    public var name: String
    public var slug: String
    public var description: String?
    public var logoUrl: String
    public var countryIso2: String
    public var countryId: UUID
    public var searchServiceId: UUID?
    public var repositoryServiceId: UUID?
    public var supportedEntityType: SupportedEntityType
    public var addedBy: String
    public var payableAmount: Double?
    public var approvedAtUtc: Date?

    public init(id: UUID, organizationId: UUID, categoryType: DocumentCategoryType, subCategoryType: DocumentSubCategoryType, documentTypeCategoryId: UUID, name: String, slug: String, description: String? = nil, logoUrl: String, countryIso2: String, countryId: UUID, searchServiceId: UUID? = nil, repositoryServiceId: UUID? = nil, supportedEntityType: SupportedEntityType, addedBy: String, payableAmount: Double? = nil, approvedAtUtc: Date? = nil) {
        self.id = id
        self.organizationId = organizationId
        self.categoryType = categoryType
        self.subCategoryType = subCategoryType
        self.documentTypeCategoryId = documentTypeCategoryId
        self.name = name
        self.slug = slug
        self.description = description
        self.logoUrl = logoUrl
        self.countryIso2 = countryIso2
        self.countryId = countryId
        self.searchServiceId = searchServiceId
        self.repositoryServiceId = repositoryServiceId
        self.supportedEntityType = supportedEntityType
        self.addedBy = addedBy
        self.payableAmount = payableAmount
        self.approvedAtUtc = approvedAtUtc
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case organizationId
        case categoryType
        case subCategoryType
        case documentTypeCategoryId
        case name
        case slug
        case description
        case logoUrl
        case countryIso2
        case countryId
        case searchServiceId
        case repositoryServiceId
        case supportedEntityType
        case addedBy
        case payableAmount
        case approvedAtUtc
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(organizationId, forKey: .organizationId)
        try container.encode(categoryType, forKey: .categoryType)
        try container.encode(subCategoryType, forKey: .subCategoryType)
        try container.encode(documentTypeCategoryId, forKey: .documentTypeCategoryId)
        try container.encode(name, forKey: .name)
        try container.encode(slug, forKey: .slug)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encode(logoUrl, forKey: .logoUrl)
        try container.encode(countryIso2, forKey: .countryIso2)
        try container.encode(countryId, forKey: .countryId)
        try container.encodeIfPresent(searchServiceId, forKey: .searchServiceId)
        try container.encodeIfPresent(repositoryServiceId, forKey: .repositoryServiceId)
        try container.encode(supportedEntityType, forKey: .supportedEntityType)
        try container.encode(addedBy, forKey: .addedBy)
        try container.encodeIfPresent(payableAmount, forKey: .payableAmount)
        try container.encodeIfPresent(approvedAtUtc, forKey: .approvedAtUtc)
    }
}

