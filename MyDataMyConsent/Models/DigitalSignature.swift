//
// DigitalSignature.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct DigitalSignature: Codable, Hashable {

    public var signedBy: String?
    public var certIssuedBy: String?
    public var validFrom: Date?
    public var validTill: Date?
    public var reason: String?
    public var location: String?
    public var sha1Digest: String?

    public init(signedBy: String? = nil, certIssuedBy: String? = nil, validFrom: Date? = nil, validTill: Date? = nil, reason: String? = nil, location: String? = nil, sha1Digest: String? = nil) {
        self.signedBy = signedBy
        self.certIssuedBy = certIssuedBy
        self.validFrom = validFrom
        self.validTill = validTill
        self.reason = reason
        self.location = location
        self.sha1Digest = sha1Digest
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case signedBy
        case certIssuedBy
        case validFrom
        case validTill
        case reason
        case location
        case sha1Digest
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(signedBy, forKey: .signedBy)
        try container.encodeIfPresent(certIssuedBy, forKey: .certIssuedBy)
        try container.encodeIfPresent(validFrom, forKey: .validFrom)
        try container.encodeIfPresent(validTill, forKey: .validTill)
        try container.encodeIfPresent(reason, forKey: .reason)
        try container.encodeIfPresent(location, forKey: .location)
        try container.encodeIfPresent(sha1Digest, forKey: .sha1Digest)
    }
}

